<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Rastrear Pedido</title>
  <link rel="manifest" href="/manifest.json" />
  <meta name="theme-color" content="#0ea5e9" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    body { margin: 0; font-family: system-ui, Arial, sans-serif; color: #0f172a; }
    header { padding: 12px 16px; background: #0ea5e9; color: #fff; }
    .panel { padding: 12px 16px; background: #fff; display: grid; gap: 8px; border-bottom: 1px solid #e2e8f0; }
    input, button { padding: 10px; border-radius: 10px; border: 1px solid #cbd5e1; font-size: 15px; }
    button { background: #0ea5e9; color: #fff; border: none; cursor: pointer; }
    #map { height: calc(100vh - 190px); }
    .row { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; }
    .muted { color: #64748b; font-size: 13px; }
    .bad { color: #b91c1c; }
    .good { color: #16a34a; }

    /* Novos estilos para ícones personalizados e rótulos */
    .car-marker, .dest-marker {
      display: flex; flex-direction: column; align-items: center;
      pointer-events: none;
    }
    .car-img {
      width: 50px; height: 50px; object-fit: contain;
      transform-origin: 50% 50%;
      transition: transform 150ms linear;
      will-change: transform;
      image-rendering: -webkit-optimize-contrast;
    }
    .dest-img {
      width: 34px; height: 34px; object-fit: contain;
      transform-origin: 50% 100%;
      image-rendering: -webkit-optimize-contrast;
    }
    .marker-label {
      margin-top: 2px;
      padding: 2px 6px;
      background: #fff;
      color: #111;
      border-radius: 10px;
      font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,.25);
      white-space: nowrap;
      transform: translateY(2px);
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <header><h2>Rastrear Pedido</h2></header>

  <div class="panel">
    <div class="row">
      <input id="orderId" placeholder="ID do pedido (ex: PED-12345)" />
      <input id="dest" placeholder="Destino (lat,lng) ou endereço" list="addrList" />
      <datalist id="addrList"></datalist>
      <button id="btnJoin">Entrar</button>
    </div>
    <div class="row" style="grid-template-columns: 1fr 1fr;">
      <div id="socketStatus" class="muted">Socket: desconectado</div>
      <div id="routeInfo" class="muted">ETA: -- | Distância: --</div>
    </div>
    <div class="muted" id="lastUpdate">Última atualização: --</div>
  </div>

  <div id="map"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    // URLs das imagens personalizadas (coloque as imagens em public/assets/)
    const CAR_IMG_URL = '/assets/carroMotorista.png';
    const DEST_IMG_URL = '/assets/casa.png';

    // Ajuste fino para alinhar a imagem do carro (se necessário)
    const CAR_OFFSET_DEG = 0;

    const $ = (id) => document.getElementById(id);
    const orderInput = $('orderId');
    const destInput = $('dest');
    const btnJoin = $('btnJoin');
    const socketStatus = $('socketStatus');
    const routeInfo = $('routeInfo');
    const lastUpdate = $('lastUpdate');
    const addrList = $('addrList');

    let map, driverMarker, destMarker, routeLine;
    let currentOrderId = '';
    let destination = null; // {lat, lng}
    let lastRoute = null; // {coordinates, distance, duration, source}
    let lastDriver = null; // {lat, lng, ts}

    // Inicializa mapa
    map = L.map('map', { zoomControl: true }).setView([-23.5505, -46.6333], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Cria ícones personalizados com imagens e rótulos
    function createCarIcon() {
      return L.divIcon({
        className: 'car-marker',
        html: `<img src="${CAR_IMG_URL}" class="car-img" alt="Motorista"/><div class="marker-label">Motorista</div>`,
        iconSize: [50, 56],
        iconAnchor: [25, 28]
      });
    }
    function createDestIcon() {
      return L.divIcon({
        className: 'dest-marker',
        html: `<img src="${DEST_IMG_URL}" class="dest-img" alt="Entrega"/><div class="marker-label">Entrega</div>`,
        iconSize: [36, 44],
        iconAnchor: [18, 36]
      });
    }

    // Função para calcular bearing entre dois pontos (para rotação do carro)
    function computeBearing(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const toDeg = r => r * 180 / Math.PI;
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const Δλ = toRad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      let brng = toDeg(Math.atan2(y, x));
      return (brng + 360) % 360; // 0..360 (0 = norte)
    }

    // Rotaciona o ícone do carro conforme heading
    function rotateCar(marker, deg) {
      if (!marker) return;
      const el = marker.getElement();
      if (!el) return;
      const img = el.querySelector('.car-img');
      if (img) img.style.transform = `rotate(${deg + CAR_OFFSET_DEG}deg)`;
    }

    // Animação suave do marcador do motorista
    function animateTo(marker, toLatLng, duration = 350) {
      if (!marker) return;
      const from = marker.getLatLng();
      const start = performance.now();
      function step(now) {
        const t = Math.min(1, (now - start) / duration);
        const lat = from.lat + (toLatLng[0] - from.lat) * t;
        const lng = from.lng + (toLatLng[1] - from.lng) * t;
        marker.setLatLng([lat, lng]);
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // Atualiza ou cria marcador do motorista
    function upsertDriver(loc) {
      if (!driverMarker) {
        driverMarker = L.marker([loc.lat, loc.lng], { icon: createCarIcon(), interactive: false }).addTo(map);
        // Ajusta bounds para motorista e destino
        const bounds = [];
        bounds.push([loc.lat, loc.lng]);
        if (destMarker) bounds.push(destMarker.getLatLng());
        if (bounds.length > 1) map.fitBounds(bounds, { padding: [40, 40] });
        else map.setView([loc.lat, loc.lng], 15);
      } else {
        animateTo(driverMarker, [loc.lat, loc.lng], 350);
      }
      let heading = Number.isFinite(loc.heading) ? loc.heading : null;
      if ((heading === null || !Number.isFinite(heading)) && lastDriver) {
        heading = computeBearing(lastDriver.lat, lastDriver.lng, loc.lat, loc.lng);
      }
      if (Number.isFinite(heading)) rotateCar(driverMarker, heading);
      lastDriver = loc;
    }

    // Atualiza ou cria marcador do destino
    function upsertDest(latlng) {
      if (!destMarker) {
        destMarker = L.marker(latlng, { icon: createDestIcon(), interactive: false }).addTo(map);
      } else {
        destMarker.setLatLng(latlng);
      }
    }

    // Função para criar marcador simples (usada para motorista e destino no código antigo)
    function setMarker(markerRef, latlng, opts = {}) {
      if (!markerRef) {
        markerRef = L.marker(latlng, opts).addTo(map);
      } else {
        markerRef.setLatLng(latlng);
      }
      return markerRef;
    }

    // Ajusta bounds para motorista e destino
    function fitBoundsToDriverAndDest() {
      const points = [];
      if (driverMarker) points.push(driverMarker.getLatLng());
      if (destMarker) points.push(destMarker.getLatLng());
      if (points.length >= 2) {
        const bounds = L.latLngBounds(points);
        map.fitBounds(bounds, { padding: [40, 40] });
      }
    }

    // Geocoding e outras funções do código anterior (mantidas sem alteração)
    async function geocode(q) {
      const r = await fetch(`/api/geocode?q=${encodeURIComponent(q)}&limit=5`);
      if (!r.ok) throw new Error('Falha no geocoding');
      return r.json();
    }

    let debounceTimer;
    destInput.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      const q = destInput.value.trim();
      if (!q || q.match(/^[-]?\d+(\.\d+)?\s*,\s*[-]?\d+(\.\d+)?$/)) {
        addrList.innerHTML = '';
        return;
      }
      debounceTimer = setTimeout(async () => {
        try {
          const results = await geocode(q);
          addrList.innerHTML = results.map(r => `<option value="${r.display_name}"></option>`).join('');
        } catch (e) {}
      }, 300);
    });

    async function resolveDestination(inputVal) {
      const val = String(inputVal || '').trim();
      const m = val.match(/^([-]?\d+(\.\d+)?)\s*,\s*([-]?\d+(\.\d+)?)$/);
      if (m) {
        const lat = parseFloat(m[1]); const lng = parseFloat(m[3]);
        return { lat, lng };
      }
      const gc = await geocode(val);
      if (!gc.length) throw new Error('Destino não encontrado.');
      return { lat: gc[0].lat, lng: gc[0].lng };
    }

    async function fetchRoute(start, end) {
      const url = `/api/route?start=${start.lat},${start.lng}&end=${end.lat},${end.lng}&profile=driving-car`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('Falha ao buscar rota');
      return r.json();
    }

    function maybeRecalculateRoute(driver, force = false) {
      if (!destination) return;
      const now = Date.now();
      const needsFirst = !lastRoute;
      const timeExceeded = lastRoute?.ts ? (now - lastRoute.ts > 30000) : false;

      let offRoute = false;
      if (lastRoute && Array.isArray(lastRoute.coordinates) && lastRoute.coordinates.length >= 2) {
        const d = distanceToPolyline(driver, lastRoute.coordinates);
        offRoute = d > 60;
      }

      if (force || needsFirst || timeExceeded || offRoute) {
        recalcRoute(driver, destination);
      }
    }

    async function recalcRoute(driver, dest) {
      try {
        const route = await fetchRoute(driver, dest);
        route.ts = Date.now();
        lastRoute = route;

        if (routeLine) routeLine.remove();
        routeLine = L.polyline(route.coordinates, { color: '#0ea5e9', weight: 5 }).addTo(map);

        const minutes = Math.max(1, Math.round(route.duration / 60));
        routeInfo.textContent = `ETA: ${minutes} min | Distância: ${(route.distance / 1000).toFixed(1)} km (${route.source})`;

        fitBoundsToDriverAndDest();
      } catch (e) {
        routeInfo.textContent = 'Falha ao calcular rota';
      }
    }

    function handleDriverLocation(loc) {
      lastDriver = { lat: loc.lat, lng: loc.lng, ts: loc.ts || Date.now() };
      upsertDriver(lastDriver);
      lastUpdate.textContent = `Última atualização: ${new Date(lastDriver.ts).toLocaleTimeString()}`;
      if (destination) maybeRecalculateRoute(lastDriver, false);
    }

    // Distância ponto -> polilinha (m)
    function haversine(a, b) {
      const R = 6371000;
      const dLat = (b.lat - a.lat) * Math.PI / 180;
      const dLng = (b.lng - a.lng) * Math.PI / 180;
      const lat1 = a.lat * Math.PI / 180;
      const lat2 = b.lat * Math.PI / 180;
      const x = Math.sin(dLat / 2) ** 2 + Math.sin(dLng / 2) ** 2 * Math.cos(lat1) * Math.cos(lat2);
      return 2 * R * Math.asin(Math.sqrt(x));
    }
    function distanceToPolyline(p, coords) {
      let min = Infinity;
      const P = { lat: p.lat, lng: p.lng };
      for (let i = 0; i < coords.length - 1; i++) {
        const A = { lat: coords[i][0], lng: coords[i][1] };
        const B = { lat: coords[i + 1][0], lng: coords[i + 1][1] };
        const d = Math.min(haversine(P, A), haversine(P, B));
        if (d < min) min = d;
      }
      return min;
    }

    async function join() {
      const id = orderInput.value.trim();
      if (!id) {
        alert('Informe o ID do pedido.');
        return;
      }
      currentOrderId = id;
      socket.emit('join_room', { orderId: id });

      const val = destInput.value.trim();
      if (val) {
        try {
          destination = await resolveDestination(val);
          upsertDest([destination.lat, destination.lng]);
          if (lastDriver) maybeRecalculateRoute(lastDriver, true);
          fitBoundsToDriverAndDest();
        } catch (e) {
          alert(e.message || 'Destino inválido');
        }
      } else {
        const urlDest = new URLSearchParams(location.search).get('dest');
        if (urlDest) {
          try {
            const [lat, lng] = urlDest.split(',').map(Number);
            destination = { lat, lng };
            destInput.value = `${lat},${lng}`;
            upsertDest([destination.lat, destination.lng]);
            if (lastDriver) maybeRecalculateRoute(lastDriver, true);
            fitBoundsToDriverAndDest();
          } catch {}
        }
      }
    }

    btnJoin.addEventListener('click', join);

    const socket = io();
    socket.on('connect', () => {
      socketStatus.textContent = 'Socket: conectado';
      socketStatus.className = 'muted good';
      if (currentOrderId) socket.emit('join_room', { orderId: currentOrderId });
    });
    socket.on('disconnect', () => {
      socketStatus.textContent = 'Socket: desconectado';
      socketStatus.className = 'muted bad';
    });
    socket.on('joined_room', ({ orderId }) => {
      socketStatus.textContent = `Socket: na sala ${orderId}`;
      socketStatus.className = 'muted good';
      socket.emit('request_latest_driver', { orderId });
    });
    socket.on('latest_driver', ({ orderId, location }) => {
      if (orderId !== currentOrderId) return;
      if (location) handleDriverLocation(location);
    });
    socket.on('driver_location', (loc) => {
      if (loc.orderId !== currentOrderId) return;
      handleDriverLocation(loc);
    });

    // Preenche inputs via query string e entra automaticamente
    (function prefill() {
      const qs = new URLSearchParams(location.search);
      const oid = qs.get('orderId');
      const dest = qs.get('dest');
      if (oid) orderInput.value = oid;
      if (dest) destInput.value = dest;
      if (oid) join();
    })();
  </script>
</body>
</html>
